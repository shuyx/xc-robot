# **XC-ROBOT 仿真规划模块设计方案**

**版本**: 1.0  
**日期**: 2025-07-18  
**目标**: 为AI助手（如Claude）提供清晰的开发指南，用于在Web GUI中实现“仿真规划”一级菜单及其下属功能。

---

## 概述

“仿真规划”模块是XC-ROBOT系统的核心大脑与演练场。它整合了从简化的逻辑验证到高保真的3D路径规划，再到可视化的任务流程编排，旨在提供一个覆盖“任务构思 -> 路径生成 -> 逻辑验证 -> 最终执行”全链路的闭环仿真与规划环境。

本模块下设三个二级菜单，层层递进：
1.  **仿真模拟 (Simulation & Emulation)**: 用于快速、低成本地验证程序逻辑和基本运动轨迹。
2.  **路径规划 (Path Planning)**: 用于在精确的3D模型中，通过手动或自动方式生成可执行的、无碰撞的运动轨迹。
3.  **任务编排 (Task Orchestration)**: 用于将复杂任务分解为原子动作，并通过可视化的方式重新组合，创造新的任务流程。

---

## 1. 子菜单一：仿真模拟 (Simulation & Emulation)

### 1.1 功能页面的UI布局和设计

此界面将复刻并优化原Qt GUI中“仿真系统”选项卡的核心功能，采用分栏布局。

- **左侧面板 (代码与控制区)**:
    - **代码输入区**: 一个多行文本框，标题为“加载或粘贴主控程序”，用于接收Python代码片段。
    - **控制按钮**: `[加载文件]`, `[▶️ 运行仿真]`, `[⏸️ 暂停]`, `[⏹️ 停止]`, `[🔄 重置]`。
    - **速度控制**: `仿真速度: [ 1.0x ]` (滑块)。

- **右侧主面板 (2D仿真视图)**:
    - **顶部分栏：底盘仿真视图**:
        - 一个2D网格画布，与原Qt版类似。
        - 一个代表底盘的**橙色矩形**，带有一个**红色箭头**指示方向。
        - 播放时，会绘制出蓝色的**历史轨迹线**和绿色的**目标路径线**。
        - 右上角显示**路径尺寸信息**（包围盒长宽）。
    - **底部分栏：机械臂仿真视图**:
        - 一个简化的“火柴人”或“连杆”风格的2D视图，用于展示双臂的关节运动。
        - 左右臂各用不同颜色（如蓝色和绿色）的线条表示连杆。
        - 实时显示每个关节的角度。

### 1.2 实现功能

1.  **程序解释器**: 作为核心功能，此界面能“读懂”用户在左侧输入的Python代码。
2.  **运动提取**: 自动从代码中解析出针对底盘（如`hermes.move_to()`)和机械臂（如`fr3.MoveJ()`, `fr3.MoveL()`)的运动指令及其目标坐标。
3.  **2D可视化**: 在右侧的2D视图中，以动画形式模拟解析出的运动轨迹。
    - **底盘**: 在网格上移动方块，并绘制路径。
    - **机械臂**: 摆动“火柴人”模型的连杆，模拟关节角度变化。
4.  **安全区域与尺寸验证**: 模拟底盘运动，并计算其路径的包围盒尺寸，用于初步评估空间占用。

### 1.3 技术路线和方案

1.  **后端 (Python)**:
    - **新增`WebBridge`接口**: 创建一个`@pyqtSlot(str, result=str)`方法，如 `run_simplified_simulation(code_string)`。
    - **创建`SimulationParser`类**: 这是实现“程序解释器”的核心。该类接收代码字符串后，**不执行代码**，而是使用**正则表达式 (Regex)** 或更高级的**抽象语法树 (AST)** 库来扫描代码，查找并提取所有运动相关的函数调用。
        - 例如，匹配模式 `robot.MoveJ\(\[(.*?)\]` 可以提取出`MoveJ`的目标关节角度。
    - **数据处理**: `SimulationParser`将提取出的所有路径点（底盘路径点序列、左臂关节角序列、右臂关节角序列）打包成一个大的JSON对象。
    - **数据返回**: `run_simplified_simulation`方法将此JSON对象作为字符串返回给前端。

2.  **前端 (JavaScript)**:
    - **接收数据**: JS调用`bridge.run_simplified_simulation()`，并通过回调函数接收到包含所有轨迹点的JSON数据。
    - **2D渲染**: 使用 **HTML5 Canvas API** 或 **SVG** 来绘制网格、底盘方块和机械臂“火柴人”模型。
    - **动画实现**: 使用 `window.requestAnimationFrame()` 创建一个动画循环。在循环中，根据当前时间和速度设置，从轨迹点数组中取出对应的点，并更新Canvas上的绘图，从而形成动画效果。
    - **播放控制**: “播放/暂停/停止”按钮分别控制动画循环的启动、暂停和重置。

---

## 2. 子菜单二：路径规划 (Path Planning)

### 2.1 功能页面的UI布局和设计

此界面将升级原“RobotSim”选项卡，专注于高保真的3D交互式路径生成。

- **中央主面板 (VTK 3D视图)**:
    - 一个大型的3D渲染窗口，显示完整的、带有关节的机器人双臂和底盘模型。
    - 包含地面网格和坐标轴指示器。
- **右侧面板 (规划与控制区)**:
    - **模式切换标签页**: `[手动规划]` 和 `[自动规划]`。
    - **“手动规划”标签页**: 
        - `规划对象`: `[选择: 右臂末端 | 左臂末端]`
        - `状态指示`: `当前状态: [待命 | 拖拽记录中...]`
        - `控制按钮`: `[开始拖拽规划]`, `[停止并保存轨迹]`, `[清空轨迹]`
        - `平滑度滑块`: `轨迹平滑度: [ 75 ] %`
    - **“自动规划”标签页**:
        - `任务来源`: `[从“智能交互”获取任务]` (下拉框，列出已解析的任务)
        - `控制按钮`: `[生成路径]`
- **底部面板 (轨迹控制)**:
    - `[在3D视图中预览轨迹]` 按钮。
    - `[发送到机器人执行]` 按钮 (高风险，需二次确认)。

### 2.2 实现功能

1.  **高保真模型显示**: 加载并渲染基于STL文件的完整机器人3D模型。
2.  **手动拖拽规划**: 用户可以在3D视图中“抓住”机械臂的末端法兰，自由拖动它来创建一条运动轨迹。3D模型会实时跟随用户的拖动而变化。
3.  **逆运动学求解**: 在拖拽过程中，系统在后台实时、高频地对末端位姿进行逆运动学(IK)求解，将笛卡尔空间的轨迹点转换为一系列的关节角度。
4.  **轨迹平滑**: 对采集到的原始、可能抖动的关节角度序列进行算法平滑（如样条插值），生成流畅的最终轨迹。
5.  **自动路径生成**: 从“智能交互”模块接收高级任务（如“抓取桌上的杯子”），自动计算出从当前位置到目标的无碰撞路径点位。
6.  **轨迹预览与执行**: 可在3D视图中回放生成的轨迹，或将其发送给真实机器人执行。

### 2.3 技术路线和方案

1.  **VTK集成 (核心挑战)**:
    - **方案**: 采用**服务器端渲染**。Python后端运行VTK，负责所有3D计算和渲染。渲染出的每一帧图像被编码后通过WebSocket实时推送到前端的`<img>`标签或Canvas上。
    - **交互**: 前端的鼠标事件（点击、拖拽、滚轮缩放）被捕获并发送回后端。后端根据这些事件更新VTK相机的位置或场景中的对象，然后渲染并回传新的一帧。

2.  **手动拖拽规划实现**: 
    - **前端**: 监听鼠标在3D视图区域的`mousedown`, `mousemove`, `mouseup`事件。
    - **后端**: 
        - 当“开始拖拽规划”被激活时，后端进入记录模式。
        - 收到`mousemove`事件传来的屏幕坐标(x, y)后，使用 **`vtkPicker`** 或类似工具，将2D屏幕点转换为3D空间中的一个点（通常是在一个与视图平行的虚拟平面上）。
        - 这个3D点成为机械臂末端的目标位姿。立即调用 `robot.GetInverseKin(0, new_pose, -1)` 进行IK求解。
        - 如果求解成功，将得到的关节角度存入一个临时数组，并更新VTK场景中的机器人模型姿态。
        - `mouseup`或“停止”按钮被点击时，停止记录。对数组中的关节角度序列应用**样条插值 (Scipy `scipy.interpolate`)** 进行平滑处理，生成最终轨迹。

3.  **自动路径生成实现**: 
    - **后端**: 新增`WebBridge`接口 `generate_path_for_task(task_id)`。
    - **创建`AutoPathPlanner`类**: 
        - 该类接收任务描述，如 `(action: grasp, object: cup, location: table)`。
        - 它需要一个**世界模型 (World Model)**，这是一个简单的数据库或JSON文件，存储了环境中关键物体（如`table`）的坐标和尺寸。
        - 使用路径规划算法（如 **RRT*** 或 **A***）在3D空间中计算一条从起点到终点的、避开已知障碍物（如世界模型中的其他物体）的路径点位。
        - 将生成的路径点位（笛卡尔坐标序列）发送给前端进行可视化。

---

## 3. 子菜单三：任务编排 (Task Orchestration)

### 3.1 功能页面的UI布局和设计

此界面将引入类似Scratch的可视化编程范式。

- **左侧面板 (动作模块工具箱)**:
    - 一个可滚动的列表，包含所有可用的原子动作模块，按类别分组：
        - **底盘运动**: `[移动到底盘]`
        - **机械臂运动**: `[关节运动]`, `[直线运动]`, `[执行轨迹]`
        - **末端工具**: `[打开夹爪]`, `[闭合夹爪]`
        - **视觉**: `[检测物体]`
        - **逻辑**: `[等待(秒)]`, `[如果...]`
- **中央主面板 (编排画布)**:
    - 一个空白的工作区，用户可以将左侧的动作模块拖拽到这里。
    - 模块之间可以像拼图一样垂直吸附、连接，形成一个任务序列。
- **右侧面板 (属性检查器)**:
    - 当用户在画布上选中一个动作模块时，此面板会显示该模块的详细参数。
    - 例如，选中`[移动到底盘]`模块，右侧会显示`X: [0.0]`, `Y: [0.0]`, `Theta: [0.0]`等输入框。
- **顶部工具栏**: `[新建任务]`, `[保存任务]`, `[加载任务]`, `[▶️ 发送到仿真模拟]`。

### 3.2 实现功能

1.  **任务分解**: 能够将一个来自“智能交互”的复杂任务，自动分解成一系列原子动作模块，并显示在编排画布上作为初始序列。
2.  **可视化编程**: 用户可以通过拖拽、排序、删除动作模块来创建或修改任务流程。
3.  **参数配置**: 用户可以点击每个动作模块，在属性检查器中设置其具体参数（如目标坐标、运动速度等）。
4.  **流程生成**: 将画布上的可视化流程转换成一个可执行的、线性的任务描述（如JSON或伪代码）。
5.  **快速验证**: 将生成的任务流程一键发送到“仿真模拟”模块，进行快速的逻辑和路径验证。

### 3.3 技术路线和方案

1.  **前端 (核心)**:
    - **采用现成的库**: 这是最高效的方案。强烈推荐使用Google的 **`Blockly`** 库。它是一个专门用于创建可视化编程界面的JavaScript库，完美支持我们所需的所有功能（工具箱、工作区、模块拖拽、连接、参数输入、代码生成）。
    - **自定义模块**: 基于`Blockly`的API，为我们的每一个原子动作（`移动到底盘`, `抓取`等）创建自定义的块(Block)。
    - **代码生成**: 配置`Blockly`，使其在用户完成编排后，能生成一个描述整个流程的**JSON对象**。

2.  **后端 (Python)**:
    - **任务分解器**: 创建一个`TaskDecomposer`类。当从“智能交互”模块接收到高级任务时，该类（可以基于规则或LLM）会生成一个符合`Blockly`格式的初始JSON结构，发送给前端进行渲染。
    - **接收编排结果**: 新增`WebBridge`接口 `run_orchestrated_task(task_json)`。
    - **任务翻译器**: 该接口接收到前端`Blockly`生成的任务JSON后，会将其**翻译**成一个简单的、线性的Python伪代码字符串。
        - 例如，一个包含“移动”和“抓取”块的JSON，会被翻译成如下字符串：
          ```python
          # Generated from Task Orchestrator
          print("Step 1: Moving chassis")
          hermes.move_to(x=1.5, y=2.0, theta=90)
          print("Step 2: Grasping")
          right_arm.move_to_joints([j1, j2, ...])
          gripper.close()
          ```
    - **与仿真模块联动**: 将生成的伪代码字符串，直接传递给为“仿真模拟”模块开发的`run_simplified_simulation(code_string)`方法，从而实现两个模块的无缝衔接。
